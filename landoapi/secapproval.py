# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""Functions related to the Security Bug Approval Process.

See https://wiki.mozilla.org/Security/Bug_Approval_Process.
"""
import logging
import operator
from typing import Dict, List, NamedTuple

from landoapi.commit_message import split_title_and_summary
from landoapi.models import SecApprovalRequest
from landoapi.phabricator import PhabricatorClient
from landoapi.projects import get_sec_approval_project_phid
from landoapi.transactions import Comment, transaction_search

logger = logging.getLogger(__name__)


# Template for submitting a sec-approval comment to Phabricator. The message is
# written in first-person form because it is being authored by the user in Lando and
# posted under their username.
#
# The message is formatted as Remarkup.
# See https://phabricator.services.mozilla.com/book/phabricator/article/remarkup/
SECURE_COMMENT_TEMPLATE = """
I have written a sanitized comment message for this revision. It should
follow the [Security Bug Approval
Guidelines](https://wiki.mozilla.org/Security/Bug_Approval_Process).

Could a member of the `sec-approval` team please review this message?
If the message is suitable for landing in mozilla-central please mark
this code review as `Accepted`.

{message_start_marker}
{message}
```
"""

MESSAGE_START_MARKER = "(message follows, do no remove this line)\n```"


class CommitDescription(NamedTuple):
    """Represents the value of a commit's title line and commit summary (body)."""

    title: str
    summary: str
    sanitized: bool


def build_transactions_for_request(
    form_content: str, updated_commit_message: str, sec_approval_project_phid: str
) -> List[Dict]:
    transactions = [
        # We must get one of the sec-approval project members to approve the
        # request and commit message for the review to proceed.
        #
        # Adding the sec-approval team to the review will clear any
        # previous reviews the team did and change their state to "blocking,
        # needs review".  Other reviewers' reviews will be left untouched. The
        # overall state of the revision will become "Needs Review".
        #
        # We need to handle the case where the sec-approval team has approved a
        # previous alternate commit message and the author has sent a new
        # message. In this case we want the review to block on the sec-approval
        # team again and for the sec-approval team to review the new message.
        # Explicitly re-adding the sec-approval team to the review will clear any
        # previous reviews the team did and change their state to "blocking,
        # needs review".
        #
        # NOTE: the 'blocking(PHID)' syntax is undocumented at the time of
        # writing.
        {"type": "reviewers.add", "value": [f"blocking({sec_approval_project_phid})"]}
    ]

    if form_content:
        transactions.append({"type": "comment", "value": form_content})

    if updated_commit_message:
        commit_review_request = make_secure_commit_message_review_comment(
            updated_commit_message
        )
        transactions.append({"type": "comment", "value": commit_review_request})

    return transactions


def make_secure_commit_message_review_comment(updated_commit_message):
    return SECURE_COMMENT_TEMPLATE.format(
        message=updated_commit_message, message_start_marker=MESSAGE_START_MARKER
    )


def send_sanitized_commit_message_for_review(revision_phid, message, phabclient):
    """Send a sanitized commit message for review by the sec-approval team.

    See https://wiki.mozilla.org/Security/Bug_Approval_Process.

    Args:
        revision_phid: The PHID of the revision to edit.
        message: The sanitized commit message string we want to be reviewed.
        phabclient: A PhabClient instance.

    Returns:
        A list of Phabricator transactions that were generated by the
        sec-approval request.
    """
    comment = SECURE_COMMENT_TEMPLATE.format(message=message)
    sec_approval_phid = get_sec_approval_project_phid(phabclient)
    response = phabclient.call_conduit(
        "differential.revision.edit",
        objectIdentifier=revision_phid,
        transactions=[
            # The caller's alternative commit message is published as a comment.
            {"type": "comment", "value": comment},
            # We must get one of the sec-approval project members to approve the
            # alternate commit message for the review to proceed.
            #
            # We need to handle the case where the sec-approval team has approved a
            # previous alternate commit message and the author has sent a new
            # message. In this case we want the review to block on the sec-approval
            # team again and for the sec-approval team to review the new message.
            # Explicitly re-adding the sec-approval team to the review will clear any
            # previous reviews the team did and change their state to "blocking,
            # needs review".  Other reviewers' reviews will be left untouched. The
            # overall state of the revision will become "Needs Review".
            #
            # NOTE: the 'blocking(PHID)' syntax is undocumented at the time of
            # writing.
            {"type": "reviewers.add", "value": [f"blocking({sec_approval_phid})"]},
        ],
    )
    return PhabricatorClient.expect(response, "transactions")


def search_sec_approval_request_for_comment(
    phab: PhabricatorClient, sec_approval_request: SecApprovalRequest
) -> Comment:
    """Search Phabricator for the comment transaction from a sec-approval request."""
    assert (
        sec_approval_request.comment_candidates
    ), "attempted to search all revision comments without providing a PHID constraint"

    object_identifier = f"D{sec_approval_request.revision_id}"
    for transaction in transaction_search(
        phab, object_identifier, sec_approval_request.comment_candidates
    ):
        if transaction["type"] == "comment":
            # We found the transaction that added a comment with our secure message.

            # The original request was posted as one comment.  It will appear as
            # a comment in this transaction's list of comments.  However, if the
            # user edited the comment after it was posted then there will be
            # additional comments in the list. Each comment holds the text after
            # editing.
            #
            # We will pick the latest comment in the list. That way if the user edits
            # their magic sec-approval request comment to revise the text of their
            # commit message then Lando will use the revised text.  Note that editing
            # could happen after the sec-approval team has approved the original
            # commit message, and a new sec-approval review will not be triggered.
            # Avoiding that is the responsibility of the revision author and the
            # person hitting the Land button.
            comments = PhabricatorClient.expect(transaction, "comments")
            comments = sorted(comments, key=operator.itemgetter("version"))
            return Comment(comments.pop())

    raise TransactionSearchError(
        f"Couldn't find a Phabricator transaction for "
        f"revision {sec_approval_request.revision_id} that contains a sec-approval "
        f"request comment"
    )


def parse_comment(comment: Comment) -> CommitDescription:
    """Parse a sec-approval request comment for a commit title and summary.

    Args:
        comment: A sec-approval request comment that was posted to Phabricator.

    Returns:
        A CommitDescription tuple of (title, summary) strings. Summary may be the empty
        string.
    """
    msg: str = PhabricatorClient.expect(comment, "content", "raw")

    if MESSAGE_START_MARKER not in msg:
        raise CommentParseError(
            f"Phabricator comment {comment['phid']} does not have a parsable "
            f"comment body: could not find message marker"
        )

    # Find the start of the "```" block and parse to the ending "```" block.
    parts = msg.split("```")
    # There should be exactly 3 parts: the comment preamble, message block,
    # and trailing spaces.
    if len(parts) != 3:
        raise CommentParseError(
            f"Phabricator comment {comment['phid']} does not have a parsable "
            f"comment body: could not find a commit message block"
        )

    title, summary = split_title_and_summary(parts[1].strip())

    if not title:
        raise CommentParseError(
            f"Phabricator comment {comment['phid']} does not have a parsable "
            f"comment body: could not find a comment title"
        )

    return CommitDescription(title, summary, sanitized=True)


class Error(Exception):
    pass


class CommentParseError(Error):
    """The sec-approval request comment could not be parsed."""

    pass


class TransactionSearchError(Error):
    """The transactions from a sec-approval request could not be retrieved from
    Phabricator.
    """

    pass
